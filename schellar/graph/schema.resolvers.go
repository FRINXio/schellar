package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/frinx/schellar/graph/model"
	"github.com/frinx/schellar/ifc"
	"github.com/frinx/schellar/scheduler"
	"github.com/sirupsen/logrus"
)

// CreateSchedule is the resolver for the createSchedule field.
func (r *mutationResolver) CreateSchedule(ctx context.Context, input model.CreateScheduleInput) (*model.Schedule, error) {
	var schedule = ifc.Schedule{
		Name:            input.Name,
		WorkflowName:    input.WorkflowName,
		WorkflowVersion: input.WorkflowVersion,
		CronString:      input.CronString,
	}

	if input.Enabled != nil {
		schedule.Enabled = *input.Enabled
	}

	if input.ParallelRuns != nil {
		schedule.ParallelRuns = *input.ParallelRuns
	}

	if input.WorkflowContext != nil {
		var workflowContext map[string]interface{}
		json.Unmarshal([]byte(*input.WorkflowContext), &workflowContext)
		schedule.WorkflowContext = workflowContext
	}

	if input.FromDate != nil {
		fromDate, err := time.Parse(time.RFC3339, *input.FromDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.FromDate = &fromDate
	}

	if input.ToDate != nil {
		toDate, err := time.Parse(time.RFC3339, *input.FromDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.ToDate = &toDate
	}

	err := schedule.ValidateAndUpdate()
	if err != nil {
		logrus.Debugf("Error validating schedule. err=%v", err)
		return nil, fmt.Errorf("Error validating schedule %s", err)
	}

	found, err := scheduler.Configuration.Db.FindByName(schedule.Name)
	if err != nil {
		logrus.Debugf("Error checking for existing schedule name. err=%v", err)
		return nil, fmt.Errorf("Error checking for existing schedule name. err=%v", err)

	}
	if found != nil {
		logrus.Debugf("Duplicate schedule name '%s'", schedule.Name)
		return nil, fmt.Errorf("Duplicate schedule name '%s'", schedule.Name)

	}

	err = scheduler.Configuration.Db.Insert(schedule)
	if err != nil {
		logrus.Debugf("Error storing schedule to the database. err=%s", err)
		return nil, fmt.Errorf("Error storing schedule to the database. err=%s", err)

	}
	scheduler.PrepareTimers()

	return ConvertIfcToModel(&schedule), nil
}

// UpdateSchedule is the resolver for the updateSchedule field.
func (r *mutationResolver) UpdateSchedule(ctx context.Context, name string, input model.UpdateScheduleInput) (*model.Schedule, error) {
	var schedule = ifc.Schedule{
		Name: name,
	}

	if input.WorkflowName != nil {
		schedule.WorkflowName = *input.WorkflowName
	}

	if input.WorkflowVersion != nil {
		schedule.WorkflowVersion = *input.WorkflowVersion
	}

	if input.CronString != nil {
		schedule.CronString = *input.CronString
	}

	if input.Enabled != nil {
		schedule.Enabled = *input.Enabled
	}

	if input.ParallelRuns != nil {
		schedule.ParallelRuns = *input.ParallelRuns
	}

	if input.WorkflowContext != nil {
		var workflowContext map[string]interface{}
		json.Unmarshal([]byte(*input.WorkflowContext), &workflowContext)
		schedule.WorkflowContext = workflowContext
	}

	if input.FromDate != nil {
		fromDate, err := time.Parse(time.RFC3339, *input.FromDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.FromDate = &fromDate
	}

	if input.ToDate != nil {
		toDate, err := time.Parse(time.RFC3339, *input.FromDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.ToDate = &toDate
	}

	err := schedule.ValidateAndUpdate()
	if err != nil {
		logrus.Debugf("Error validating schedule. err=%v", err)
		return nil, fmt.Errorf("Error validating schedule %s", err)
	}

	found, err := scheduler.Configuration.Db.FindByName(schedule.Name)
	if err != nil {
		logrus.Debugf("Error checking for existing schedule name. err=%v", err)
		return nil, fmt.Errorf("Error checking for existing schedule name")

	}
	if found == nil {
		logrus.Debugf("Schedule not found with name '%s'", schedule.Name)
		return nil, fmt.Errorf("Schedule not found with name '%s'", schedule.Name)

	}

	err = scheduler.Configuration.Db.Update(schedule)
	if err != nil {
		logrus.Debugf("Error storing schedule to the database. err=%s", err)
		return nil, fmt.Errorf("Error storing schedule to the database. err=%s", err)

	}

	scheduler.PrepareTimers()
	return ConvertIfcToModel(&schedule), nil
}

// DeleteSchedule is the resolver for the deleteSchedule field.
func (r *mutationResolver) DeleteSchedule(ctx context.Context, name string) (bool, error) {
	err := scheduler.Configuration.Db.RemoveByName(name)
	if err != nil {
		logrus.Debugf("Error deleting schedule. err=%v", err)
		return false, fmt.Errorf("Error deleting schedule. err=%v", err)
	}

	scheduler.PrepareTimers()
	return true, nil
}

// Schedule is the resolver for the schedule field.
func (r *queryResolver) Schedule(ctx context.Context, name string) (*model.Schedule, error) {
	schedule, err := scheduler.Configuration.Db.FindByName(name)
	if err != nil {
		logrus.Debugf("Error getting schedule with name '%s'. err=%v", name, err)
		return nil, fmt.Errorf("Error getting schedule with name '%s'. err=%v", name, err)
	}

	if schedule == nil {
		logrus.Debugf("Error getting schedule with name '%s'", name)
		return nil, fmt.Errorf("Error getting schedule with name '%s'", name)
	}

	return ConvertIfcToModel(schedule), nil
}

// Schedules is the resolver for the schedules field.
func (r *queryResolver) Schedules(ctx context.Context, after *string, before *string, first *int, last *int, filter *model.SchedulesFilterInput) (*model.ScheduleConnection, error) {

	schedules := GetSchedulesFilter(filter)

	totalCount := len(schedules)
	// schedules = FilterSchedules(filter, schedules)

	var cursor string

	if after != nil {
		cursor = *after
		schedules = getScheduleAfterCursor(cursor, schedules)
	}

	if before != nil {
		cursor = *before
		schedules = getScheduleBeforeCursor(cursor, schedules)
	}

	for _, schedule := range schedules {
		log.Println(schedule)
	}

	filteredCount := len(schedules)

	if first != nil {

		endIndex := *first
		if endIndex > filteredCount {
			endIndex = filteredCount
		}
		schedules = schedules[0:endIndex]
	}

	if last != nil {
		startIndex := filteredCount - *last
		if startIndex < 0 {
			startIndex = 0
		}
		schedules = schedules[startIndex:filteredCount]
	}

	edges := make([]*model.ScheduleEdge, len(schedules))
	for i, schedule := range schedules {
		cursor := schedule.Name
		edges[i] = &model.ScheduleEdge{
			Cursor: cursor,
			Node:   schedule,
		}
	}

	var statsCursor string = ""
	var endCursor string = ""

	if len(edges) > 0 {
		statsCursor = edges[0].Cursor
		endCursor = edges[len(edges)-1].Cursor
	}

	pageInfo := model.PageInfo{
		StartCursor:     &statsCursor,
		EndCursor:       &endCursor,
		HasPreviousPage: false,
		HasNextPage:     false,
	}

	connections := model.ScheduleConnection{
		Edges:      edges,
		PageInfo:   &pageInfo,
		TotalCount: totalCount,
	}
	return &connections, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
