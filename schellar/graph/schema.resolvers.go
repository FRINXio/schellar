package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/frinx/schellar/graph/model"
	"github.com/frinx/schellar/ifc"
	"github.com/frinx/schellar/scheduler"
	"github.com/sirupsen/logrus"
)

// CreateSchedule is the resolver for the createSchedule field.
func (r *mutationResolver) CreateSchedule(ctx context.Context, input model.CreateScheduleInput) (*model.Schedule, error) {
	err := checkPermissions(ctx)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("%v", err)
	}

	var schedule = ifc.Schedule{
		Name:            input.Name,
		WorkflowName:    input.WorkflowName,
		WorkflowVersion: input.WorkflowVersion,
		CronString:      input.CronString,
	}

	if input.Enabled != nil {
		schedule.Enabled = *input.Enabled
	}

	if input.ParallelRuns != nil {
		schedule.ParallelRuns = *input.ParallelRuns
	}

	if input.WorkflowContext != nil {
		var workflowContext map[string]interface{}
		json.Unmarshal([]byte(*input.WorkflowContext), &workflowContext)
		schedule.WorkflowContext = workflowContext
	}

	if input.FromDate != nil {
		fromDate, err := time.Parse(time.RFC3339, *input.FromDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.FromDate = &fromDate
	}

	if input.ToDate != nil {
		toDate, err := time.Parse(time.RFC3339, *input.ToDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.ToDate = &toDate
	}

	err = schedule.ValidateAndUpdate()
	if err != nil {
		logrus.Debugf("Error validating schedule. err=%v", err)
		return nil, fmt.Errorf("Error validating schedule %s", err)
	}

	found, err := scheduler.Configuration.Db.FindByName(schedule.Name)
	if err != nil {
		logrus.Debugf("Error checking for existing schedule name. err=%v", err)
		return nil, fmt.Errorf("Error checking for existing schedule name. err=%v", err)

	}
	if found != nil {
		logrus.Debugf("Duplicate schedule name '%s'", schedule.Name)
		return nil, fmt.Errorf("Duplicate schedule name '%s'", schedule.Name)

	}

	err = scheduler.Configuration.Db.Insert(schedule)
	if err != nil {
		logrus.Debugf("Error storing schedule to the database. err=%s", err)
		return nil, fmt.Errorf("Error storing schedule to the database. err=%s", err)

	}
	scheduler.PrepareTimers()

	return ConvertIfcToModel(&schedule), nil
}

// UpdateSchedule is the resolver for the updateSchedule field.
func (r *mutationResolver) UpdateSchedule(ctx context.Context, name string, input model.UpdateScheduleInput) (*model.Schedule, error) {
	err := checkPermissions(ctx)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("%s", err)
	}

	err = ValidateName(name)
	if err != nil {
		logrus.Debugf("Error validating schedule. err=%v", err)
		return nil, fmt.Errorf("Error validating schedule %s", err)
	}

	schedule, err := scheduler.Configuration.Db.FindByName(name)
	if err != nil {
		logrus.Debugf("Error checking for existing schedule name. err=%v", err)
		return nil, fmt.Errorf("Error checking for existing schedule name")

	}
	if schedule == nil {
		logrus.Debugf("Schedule not found with name '%s'", name)
		return nil, fmt.Errorf("Schedule not found with name '%s'", name)
	}

	if input.WorkflowName != nil {
		schedule.WorkflowName = *input.WorkflowName
	}

	if input.WorkflowVersion != nil {
		schedule.WorkflowVersion = *input.WorkflowVersion
	}

	if input.CronString != nil {
		schedule.CronString = *input.CronString
	}

	if input.Enabled != nil {
		schedule.Enabled = *input.Enabled
	}

	if input.ParallelRuns != nil {
		schedule.ParallelRuns = *input.ParallelRuns
	}

	if input.WorkflowContext != nil {
		var workflowContext map[string]interface{}
		json.Unmarshal([]byte(*input.WorkflowContext), &workflowContext)
		schedule.WorkflowContext = workflowContext
	}

	if input.FromDate != nil {
		fromDate, err := time.Parse(time.RFC3339, *input.FromDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.FromDate = &fromDate
	}

	if input.ToDate != nil {
		toDate, err := time.Parse(time.RFC3339, *input.ToDate)
		if err != nil {
			fmt.Println("Error while parsing the date time :", err)
			return nil, fmt.Errorf("Error while parsing the date time. err=%v", err)

		}
		schedule.ToDate = &toDate
	}
	err = schedule.ValidateAndUpdate()

	if err != nil {
		logrus.Debugf("Error validating schedule. err=%v", err)
		return nil, fmt.Errorf("Error validating schedule %s", err)
	}

	err = scheduler.Configuration.Db.Update(*schedule)
	if err != nil {
		logrus.Debugf("Error storing schedule to the database. err=%s", err)
		return nil, fmt.Errorf("Error storing schedule to the database. err=%s", err)

	}

	scheduler.PrepareTimers()
	return ConvertIfcToModel(schedule), nil
}

// DeleteSchedule is the resolver for the deleteSchedule field.
func (r *mutationResolver) DeleteSchedule(ctx context.Context, name string) (bool, error) {
	err := checkPermissions(ctx)
	if err != nil {
		fmt.Println(err)
		return false, fmt.Errorf("%s", err)
	}

	schedule, err := scheduler.Configuration.Db.FindByName(name)
	if err != nil {
		logrus.Debugf("Error getting schedule with name '%s'. err=%v", name, err)
		return false, fmt.Errorf("Error getting schedule with name '%s'. err=%v", name, err)
	}

	if schedule == nil {
		logrus.Debugf("Error getting schedule with name '%s'", name)
		return false, fmt.Errorf("Error getting schedule with name '%s'", name)
	}

	err = scheduler.Configuration.Db.RemoveByName(name)
	if err != nil {
		logrus.Debugf("Error deleting schedule. err=%v", err)
		return false, fmt.Errorf("Error deleting schedule. err=%v", err)
	}

	scheduler.PrepareTimers()
	return true, nil
}

// Schedule is the resolver for the schedule field.
func (r *queryResolver) Schedule(ctx context.Context, name string) (*model.Schedule, error) {
	err := checkPermissions(ctx)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("%v", err)
	}

	schedule, err := scheduler.Configuration.Db.FindByName(name)
	if err != nil {
		logrus.Debugf("Error getting schedule with name '%s'. err=%v", name, err)
		return nil, fmt.Errorf("Error getting schedule with name '%s'. err=%v", name, err)
	}

	if schedule == nil {
		logrus.Debugf("Schedule with name '%s' not exist", name)
		return nil, fmt.Errorf("Schedule with name '%s' not exist", name)
	}

	return ConvertIfcToModel(schedule), nil
}

// Schedules is the resolver for the schedules field.
func (r *queryResolver) Schedules(ctx context.Context, after *string, before *string, first *int, last *int, filter *model.SchedulesFilterInput) (*model.ScheduleConnection, error) {
	err := checkPermissions(ctx)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("%v", err)
	}

	err = handlePagination(after, before, first, last)
	if err != nil {
		return nil, err
	}

	if after != nil && *after == "" {
		after = nil
	}

	if before != nil && *before == "" {
		before = nil
	}

	var schedules []*model.Schedule

	if filter != nil {
		schedules = GetSchedulesFilter(filter)
	} else {
		schedules = GetSchedules()
	}

	totalCount := len(schedules)

	var hasNext bool = false
	var hasPrevious bool = false
	var statsCursor string = ""
	var endCursor string = ""
	var edges = make([]*model.ScheduleEdge, 0)

	if totalCount > 0 {

		if after == nil && first != nil {
			schedules, hasPrevious, hasNext = getSchedulesFirst(schedules, first)
		}

		if after != nil && first != nil {
			schedules, hasPrevious, hasNext = getSchedulesFirstAfter(schedules, first, after)
		}

		if before == nil && last != nil {
			schedules, hasPrevious, hasNext = getSchedulesLast(schedules, last)
		}

		if before != nil && last != nil {
			schedules, hasPrevious, hasNext = getSchedulesLastBefore(schedules, last, before)
		}

		edges = make([]*model.ScheduleEdge, len(schedules))
		for i, schedule := range schedules {
			cursor := schedule.Name
			edges[i] = &model.ScheduleEdge{
				Cursor: cursor,
				Node:   schedule,
			}
		}
		if len(edges) > 0 {
			statsCursor = edges[0].Cursor
			endCursor = edges[len(edges)-1].Cursor
		}
	}

	pageInfo := model.PageInfo{
		StartCursor:     &statsCursor,
		EndCursor:       &endCursor,
		HasPreviousPage: hasPrevious,
		HasNextPage:     hasNext,
	}

	connections := model.ScheduleConnection{
		Edges:      edges,
		PageInfo:   &pageInfo,
		TotalCount: totalCount,
	}
	return &connections, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
